/* Like $.extend, first argument is the object to be extended, subsequent
	arguments are objects which extend it
	The first argument may also be set to true, indicating a deep extension
	- in this case, the second object is the object to be extended */
function extend() {
	var first = 0, object = arguments[first], ext;

	if(object === true) {
		object = arguments[++first];
		ext = function(extender, key) {
			var val = extender[key];
			if(val) {  }
			else { object[key] = val; }
		};
	}
	else { ext = function(extender, key) { object[key] = extender[key]; }; }

	function each() {
		for(var a in arguments) {
			var extender = arguments[a];
			for(var e in extender) { ext(extender, e); }
		}
	}

	each.apply(null, Array.prototype.slice.call(arguments, first+1));

	return object;
}


/* Adapted from John Resig's instanceOf - http://ejohn.org/blog/objectgetprototypeof/ */
function instance(object, Class) {
	for(var prototype = Object.getPrototypeOf(object); prototype;
		prototype = Object.getPrototypeOf(prototype)) {
		if(prototype === Class.prototype) { return true; }
	}

	return false;
}


function Vec2D(x, y) { this.x = (x || 0); this.y = (y || 0); }
$.extend(Vec2D.prototype, {
	/* Accessors */
	
	add: function(other) { return this.copy().doAdd(other); },
	
	angleAbs: function(other) {
		var prodMag = Math.sqrt(this.mag2()*other.mag2());
		if(magProd) { return Math.acos(this.dot(other)/prodMag); }
		else { $.error("Vec2D Error: getting angle with zero vector"); }
	},
	
	angleRel: function(other) {
		return Math.atan2(this.dot(other.perp()), this.dot(other));
	},
	
	copy: function(other) {
		if(other) { this.x = other.x; this.y = other.y; return this; }
		else { return new this.constructor(this.x, this.y); }
	},
	
	dist: function(other) { return Math.sqrt(this.distSq(other)); },
	
	distSq: function(other) {
		var x = other.x-this.x, y = other.y-this.y; return x*x+y*y;
	},
	
	dot: function(other) { return this.x*other.x+this.y*other.y; },
	
	equals: function(other) {
		return (this.x === other.x && this.y === other.y);
	},

	pinToRange: function(min, max) {
		return this.copy().doPinToRange(min, max);
	},
	
	mag: function() { return Math.sqrt(this.magSq()); },
	
	magSq: function() { return this.x*this.x+this.y*this.y; },
	
	mult: function(other) { return this.copy().doMult(other); },
	
	perp: function() { return this.copy().doPerp(); },
	
	scale: function(m) { return this.copy().doScale(m); },
	
	sub: function(other) { return this.copy().doSub(other); },
	
	unit: function() { return this.copy().doUnit(); },
	
	/* Mutators */
	
	doAdd: function(other) { this.x += other.x; this.y += other.y; return this; },

	doPinToRange: function(min, max) {
		if(max < min) { log("Vec2D Warning: max value less than min value"); }
		var magSq = this.magSq(),
			limitSq = Math.pinToRange(min*min, magSq, max*max);
		
		if(magSq && magSq !== limitSq) {
			this.doUnit().doScale(Math.sqrt(limitSq));
		}
		return this;
	},
	
	doMult: function(other) { this.x *= other.x; this.y *= other.y; return this; },
	
	doPerp: function() {
		// Left
		var x = this.x; this.x = -this.y; this.y = x; return this;
	},
	
	doScale: function(m) { this.x *= m; this.y *= m; return this; },
	
	doSub: function(other) { this.x -= other.x; this.y -= other.y; return this; },
	
	doUnit: function() {
		var mag = this.mag();
		if(mag) { this.x /= mag; this.y /= mag; return this; }
		else { $.error("Vec2D Error: normalising zero vector"); }
	},
	
	doZero: function() { this.x = this.y = 0; return this; }
});


/* Conversion functions adapted from Michael Jackson's (really) - http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript */
function Color(r, g, b, a) {
	this.r = (r || 0);
	this.g = (g || 0);
	this.b = (b || 0);
	this.a = (a || 1);
}
$.extend(Color.prototype, {
	fromHSLA: function(h, s, l, a) {
		h /= 359;
		s /= 100;
		l /= 100;

		this.a = a;

		if(s === 0) { this.r = this.g = this.b = l; }
		else {
			var hueToRGB = function(p, q, t) {
				if(t < 0) { ++t; }
				else if(t > 1) { --t; }
				
				return ((t < 1/6)? p+(q-p)*6*t
					:	((t < 1/2)? q
					:	((t < 2/3)? p+(q-p)*(2/3-t)*6
					:	p)));
			};

			var q = ((l < 0.5)? l*(1+s) : l+s-l*s);
			var p = 2*l-q;
			
			this.r = hueToRGB(p, q, h+1/3);
			this.g = hueToRGB(p, q, h);
			this.b = hueToRGB(p, q, h-1/3);
		}
		
		return this;
	},
	fromRGBA: function(r, g, b, a) {
		this.r = r/255; this.g = g/255; this.b = b/255; this.a = a;
		
		return this;
	},
	toRGBA: function() {
		return { r: (this.r*255) | 0, g: (this.g*255) | 0,
			b: (this.b*255) | 0, a: this.a };
	},
	toHSLA: function() {
		var max = Math.max(this.r, this.g, this.b),
			min = Math.min(this.r, this.g, this.b),
			h, s, l = (max+min)/2;

		if(max == min){
			h = s = 0; // achromatic
		}
		else {
			var d = max-min;
			
			s = ((l > 0.5) ? d/(2-max-min) : d/(max+min));
			
			switch(max){
				case this.r:
					h = (this.g-this.b)/d+((this.g < this.b)? 6 : 0);
				break;
				case this.g:
					h = (this.b-this.r)/d+2;
				break;
				case this.b:
					h = (this.r-this.g)/d+4;
				break;
			}
			h /= 6;
		}

		return { h: (h*360) | 0, s: (s*100) | 0, l: (l*100) | 0, a: this.a };
	},
	RGBAString: function() {
		var rgba = this.toRGBA();
		return "rgba("+rgba.r+", "+rgba.g+", "+rgba.b+", "+rgba.a+")";
	},
	HSLAString: function() {
		var hsla = this.toHSLA();
		return "hsla("+hsla.h+", "+hsla.s+", "+hsla.l+", "+hsla.a+")";
	}
});
$.extend(Color, {
	fromHSLA: function(h, s, l, a) {
		return (new Color()).fromHSLA(h, s, l, a);
	},
	fromRGBA: function(r, g, b, a) {
		return (new Color()).fromRGBA(r, g, b, a);
	}
});